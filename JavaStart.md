#### DOS 命令

` rd /s /q [目录名]`  windows 递归删除目录及目录里的内容

**修改本次命令行编码为**

* UTF-8	

```shell
chcp 65001
```

* GBK

```shell
chcp 936
```

#### 字符编码问题

- 在NotePad++等编辑器中，修改源文件的字符编码
- 在使用javac命令式，可以指定源文件的字符编码
```shell
javac -encoding utf-8 Review01.java
```


#### 文档注释

```shell
javadoc -d mydoc -author -version HelloWorld.java
```

#### Java 其他修饰符关键字
* native
* strictfp(strict float point):精确浮点数，修饰类、方法、变量
* transient:修饰变量，在对象序列化过程中，忽略序列化此变量
* volatile:
  - 保证不同线程之间对共享变量操作的可见性
  - 通过禁止编译器、CPU指令重排序和部分happens-before规则解决有效性
* assert:断言，false则抛出异常
* const
* goto

#### 变量名为什么不能以数字开头
>变量由字母、数字（0-9）、下划线（_）和美元符号（$）组成

1.[***词法分析说***](https://www.zhihu.com/question/19581495)

因为每次输入“头符号”后要判断该符号是数字还是字符，如果是数字，则可以直接跳入数字处理的模块，若是字符则按变量名来处理。
如果允许变量名以数字开头，则以后每次输入一个符号都要做一次“是否为数字”的判断，直到符号出现非数字再转成变量名，而禁止以数字开头只需要判断一次，很显然“每一次都要判断”是一种极大的浪费。
另外变量名以数字开头对程序员而言也没有任何的帮助，反而降低了编译器的性能，毕竟O(1)和O(n)还是差距不小的。  
2.***现有的数据无法区分***  
　　科学计数：1e3
　　某些数值：100000L,100f
　　程序逻辑错误：int 1 = 2; if (1 == 2) {...}
#### Java 中变量的数据类型
- 基本数据类型：
  * 整数类型：
      定义long类型的变量，值以'L'或'l'结尾作为后缀，Java的整型常量默认为int型
  * 浮点数类型：
      定义float类型的变量，赋值时以'F'或'f'作为后缀，Java的浮点型变量默认为double型 
    指数：a^n a为底数，n为指数，n个a相乘  
    尾数：  
     1. 指自然数的末位（个位、最后一位）数字
     2. 指有理数之中浮点数位于小数点后面的数

    [单精度浮点数(float32)存储与表示方式](https://zhuanlan.zhihu.com/p/632347955)
  * 字符类型
  * 布尔类型
- 引用数据类型
  * 类（class）
  * 接口（interface）
  * 数组（[]）
  * 枚举（enum)
  * 注解（@interface）
  * 记录（record）

#### GBxxx 字符集
>GB 就是国标的意思，是为了显示中文而设计的一套字符集。
GB2312：简体中文码表。一个小于 127 的字符的意义与原来相同，即向下兼容 ASCII
码。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含
7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这
就是常说的"***全角***"字符，而原来在 127 号以下的那些符号就叫"***半角***"字符了。
GBK：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了双字节编码方
案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体汉字以及日韩汉
字等。
GB18030：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1
个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩
汉字等。

#### [a,b]范围内的随机整数

```java
(int)(Math.random() * (b - a +1))+a
```

##### 一维数组

**声明：**

//推荐 

元素的数据类型[] 一维数组的名称; 

//不推荐 

元素的数据类型 一维数组名[];

**初始化：**

- 静态初始化：数组变量的初始化和数组元素的赋值操作同时进行，本质是用静态数据（编译时已知）为数组初始化。此时数组的长度由静 态数据的个数决定

  **一维数组声明和静态初始化格式 1：**

  数据类型[] 数组名 = new 数据类型[]{元素 1,元素 2,元素 3,...}; 

  或 

  数据类型[] 数组名; 数组名 = new 数据类型[]{元素 1,元素 2,元素 3,...};

​     **一维数组声明和静态初始化格式 2：**

​     数据类型[] 数组名 = {元素 1,元素 2,元素 3...};//必须在一个语句中完成，不能 分成两个语句写

- 动态初始化：数组变量的初始化和数组元素的赋值操作分开进行

  **格式：**

  数组存储的元素的数据类型[] 数组名字 = new 数组存储的元素的数据类型[长度]; 

  或 

  数组存储的数据类型[] 数组名字; 数组名字 = new 数组存储的数据类型[长度];

#### 二维数组

**声明：**

//推荐 

元素的数据类型[] [] 二维数组的名称; 

//不推荐 

元素的数据类型 二维数组名[] []; 

//不推荐 

元素的数据类型[] 二维数组名[];

**初始化：**

- 静态初始化：

  ```java
  int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}};
  ```

- 动态初始化：

  - **规则二维表：每一行的列数是相同的**

    //（1）确定行数和列数 元素的数据类型[][] 

    二维数组名 = new 元素的数据类型[m][n]; 

    //其中，m:表示这个二维数组有多少个一维数组。或者说一共二维表有几行 

    //其中，n:表示每一个一维数组的元素有多少个。或者说每一行共有一个单元格 

    //此时创建完数组，行数、列数确定，而且元素也都有默认值 

    //（2）再为元素赋新值 

    二维数组名[行下标][列下标] = 值;

  - **不规则：每一行的列数不一样**

    //（1）先确定总行数 

    元素的数据类型[][] 二维数组名 = new 元素的数据类型[总行数] []; 

    //此时只是确定了总行数，每一行里面现在是 null 

    //（2）再确定每一行的列数，创建每一行的一维数组 

    二维数组名[行下标] = new 元素的数据类型[该行的总列数]; 

    //此时已经 new 完的行的元素就有默认值了，没有 new 的行还是 null 

    //(3)再为元素赋值 

    二维数组名[行下标] [列下标] = 值

### 数组元素查找
- 顺序查找
- 二分法查找
